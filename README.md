# Description

Generates a property accessor based on https://github.com/symfony/property-access which will cache
the access methods. This will make it faster.

Each time the class structure is changed, recompile again.

Will create a "pool", an object aware of another set of objects, which knows how to 
perform get/set operations on them.

Can generate as many "pools" as you wont.

It works only with objects, it is not it's scope to deal with array for the moment.

# Demo

## Create a cache pool to access one object for demo
````PHP

require_once("../vendor/autoload.php");

use Ingres\PropertyAccess\ObjectAccess;
use Ingres\PropertyAccess\ObjectPoolAccessBuilder;
use Ingres\PropertyAccess\BridgePropertyAccess;
use Symfony\Component\PropertyAccess\PropertyAccess;

/*
 * Class used for a basic test
 */
class Client
{
    protected $id;

    public $name;

    public $email;

    public $addresses = [];

    public function setId($id)
    {
        $this->id = $id;
    }

    public function getName()
    {
        return $this->name;
    }
}

$client = new Client();

$objectAccess = new ObjectAccess($client, [ 'id', 'name', 'email', 'addresses' ], [ 'Proxy\__GC__\\' ]);
$objectPoolAccessBuilder = new ObjectPoolAccessBuilder();

$className = 'AutoGeneratedPropertyAccessor';

list(
    $classContent, //the class code
    $classFullName, //full name of the class, including namespace: Ingres\PropertyAccess\AutoGeneratedPropertyAccessor
    $ignoredPropertiesCollection
) = $objectPoolAccessBuilder->generatePoolAccess([ $objectAccess ], true, $className);

````

## Save the cache on disk.

````PHP
$pathToFileCache = __DIR__ . '/' . $className . '.php';

$written = file_put_contents($pathToFileCache, $classContent);
if ($written === false) {
    throw new \Exception("Class {$className} can not be written");
}

````

# Use cache pool created for Client object

````PHP

/*
 * Later, use the cached class as property accessor. Create a fallback based on symfony property accessor
 * which will report in logs, if enabled, any property which could not be accessed from cache pool
 *
 * So, a bridge must be created between cache pool and native implementation
 */

// load class
require_once($pathToFileCache);

// get instance, singleton since nothing is changed during request
$instance = call_user_func_array([ $classFullName, 'getInstance'], []);
$bridgePropertyAccess = new BridgePropertyAccess();
$nativeAccessor = PropertyAccess::createPropertyAccessor();

$bridgePropertyAccess->setObjectPoolPropertyAccess($instance);
$bridgePropertyAccess->setCanLog(true); // log if any property is not found in cache pool
$bridgePropertyAccess->setUsePool(true); // use cache pool as first priority, instead of native property accessor
$bridgePropertyAccess->setLogger(new \Psr\Log\NullLogger()); //create logger
$bridgePropertyAccess->setNativePropertyAccess($nativeAccessor);
````