# Description

Generates a property accessor based on https://github.com/symfony/property-access which will cache
the access methods. This will make it faster.

Each time the class structure is changed, recompile again.

Will create a "pool", an object aware of another set of objects, which knows how to 
perform get/set operations on them.

Can generate as many "pools" as you wont.

It works only with objects, it is not it's scope to deal with array for the moment.

# Demo

## Create a cache pool to access one object for demo
````PHP

require_once("../vendor/autoload.php");

use Ingres\PropertyAccess\ObjectAccess;
use Ingres\PropertyAccess\ObjectPoolAccessBuilder;
use Ingres\PropertyAccess\BridgePropertyAccess;
use Symfony\Component\PropertyAccess\PropertyAccess;

/*
 * Class used for a basic test
 */
class Client
{
    protected $id;

    public $name;

    public $email;

    public $addresses = [];

    public function setId($id)
    {
        $this->id = $id;
    }

    public function getName()
    {
        return $this->name;
    }
}

$client = new Client();

$objectAccess = new ObjectAccess($client, [ 'id', 'name', 'email', 'addresses' ], [ 'Proxy\__GC__\\' ]);
$objectPoolAccessBuilder = new ObjectPoolAccessBuilder();

$className = 'AutoGeneratedPropertyAccessor';

list(
    $classContent, //the class code
    $classFullName, //full name of the class, including namespace: Ingres\PropertyAccess\AutoGeneratedPropertyAccessor
    $ignoredPropertiesCollection
) = $objectPoolAccessBuilder->generatePoolAccess([ $objectAccess ], true, $className);

````

## Save the cache on disk.

````PHP
$pathToFileCache = __DIR__ . '/' . $className . '.php';

$written = file_put_contents($pathToFileCache, $classContent);
if ($written === false) {
    throw new \Exception("Class {$className} can not be written");
}

````

# Use cache pool created for Client object

````PHP

/*
 * Later, use the cached class as property accessor. Create a fallback based on symfony property accessor
 * which will report in logs, if enabled, any property which could not be accessed from cache pool
 *
 * So, a bridge must be created between cache pool and native implementation
 */

// load class
require_once($pathToFileCache);

// get instance, singleton since nothing is changed during request
$instance = call_user_func_array([ $classFullName, 'getInstance'], []);
$bridgePropertyAccess = new BridgePropertyAccess();
$nativeAccessor = PropertyAccess::createPropertyAccessor();

$bridgePropertyAccess->setObjectPoolPropertyAccess($instance);
$bridgePropertyAccess->setCanLog(true); // log if any property is not found in cache pool
$bridgePropertyAccess->setUsePool(true); // use cache pool as first priority, instead of native property accessor
$bridgePropertyAccess->setLogger(new \Psr\Log\NullLogger()); //create logger
$bridgePropertyAccess->setNativePropertyAccess($nativeAccessor);
````

# Generated Class

````PHP
<?php

namespace Ingres\PropertyAccess;

use Symfony\Component\PropertyAccess\PropertyAccessorInterface;


/**
 * Class ObjectPoolPropertyAccess
 * @package Ingres\Symfony\PropertyAccess
 */
class AutoGeneratedPropertyAccessor implements ObjectPoolPropertyAccessInterface
{
    /**
     * @var array|GeneratedPropertyAccessorInterface[]
     */
    protected $classPropertyAccessors = [];

    /** @var ObjectPoolPropertyAccess */
    protected static $instance = null;

    /**
     * Since nothing can change during runtime, this must be a singleton
     *
     * @return ObjectPoolPropertyAccess
     */
    public static function getInstance()
    {
        if (self::$instance === null) {
            self::$instance = new self();
        }

        return self::$instance;
    }

    /**
     * ObjectPoolPropertyAccess constructor.
     */
    protected function __construct()
    {
$autoGeneratedAnonymousClass_1 =  new class ()
    implements
        PropertyAccessorInterface
{
    const READ_FUNCTION_PREFIX = 'get_';

    const WRITE_FUNCTION_PREFIX = 'set_';

    const WRITE_COLLECTION_FUNCTION_PRFIX = 'set_c_';

    protected $isWritable = [
'name' => true,
'email' => true,
'addresses' => true,
    ];

    protected $isReadable = [
'name' => true,
'email' => true,
'addresses' => true,
    ];

    protected $setters = [
'name' => 'set_name',
'email' => 'set_email',
'addresses' => 'set_addresses'
    ];

    protected $collectionSetters = [
'name' => 'set_c_name',
'email' => 'set_c_email',
'addresses' => 'set_c_addresses'
    ];

    protected $getters = [
'name' => 'get_name',
'email' => 'get_email',
'addresses' => 'get_addresses'
    ];

    /**
     * {@inheritdoc}
     */
    public function setValue(&$objectOrArray, $propertyPath, $value)
    {
        if (is_array($value) || $value instanceof \Traversable) {
            $method = $this->collectionSetters[$propertyPath];
        } else {
            $method = $this->setters[$propertyPath];
        }

        return $this->{$method}($objectOrArray, $value);
    }
    /**
     * {@inheritdoc}
     */
    public function getValue($objectOrArray, $propertyPath)
    {
        return $this->{$this->getters[$propertyPath]}($objectOrArray);
    }

    /**
     * {@inheritdoc}
     */
    public function isWritable($objectOrArray, $propertyPath)
    {
        if (!isset($this->isWritable[$propertyPath])) {
            throw new \InvalidArgumentException("Property path $propertyPath is not found in isWritable list");
        }

        return $this->isWritable[$propertyPath];
    }

    /**
     * {@inheritdoc}
     */
    public function isReadable($objectOrArray, $propertyPath)
    {
        if (!isset($this->isReadable[$propertyPath])) {
            throw new \InvalidArgumentException("Property path $propertyPath is not found in isReadable list");
        }

        return $this->isReadable[$propertyPath];
    }

    /**
     * @param $property
     * @param $operation
     * @return bool
     * @throws \Exception
     */
    public function hasAccessToOperation($property, $operation)
    {
        if ($operation === ObjectAccess::OPERATION_GET) {

            return isset($this->getters[$property]);

        } elseif ($operation === ObjectAccess::OPERATION_SET) {

            return isset($this->setters[$property]);

        } else {
            throw new \Exception("Operation " . $operation . ' is not recognized');
        }
    }


    // function autoGenerated
    public function set_name( $objectOrArray , $value)
    {
        return $objectOrArray->name = $value;
    }
    

    // function autoGenerated
    public function set_email( $objectOrArray , $value)
    {
        return $objectOrArray->email = $value;
    }
    

    // function autoGenerated
    public function set_addresses( $objectOrArray , $value)
    {
        return $objectOrArray->addresses = $value;
    }
    


    // function autoGenerated
    public function set_c_name( $objectOrArray , $value)
    {
        return $objectOrArray->name = $value;
    }
    

    // function autoGenerated
    public function set_c_email( $objectOrArray , $value)
    {
        return $objectOrArray->email = $value;
    }
    

    // function autoGenerated
    public function set_c_addresses( $objectOrArray , $value)
    {
        return $objectOrArray->addresses = $value;
    }
    


    // function autoGenerated
    public function get_name( $objectOrArray )
    {
        return $objectOrArray->getName();
    }
    

    // function autoGenerated
    public function get_email( $objectOrArray )
    {
        return $objectOrArray->email;
    }
    

    // function autoGenerated
    public function get_addresses( $objectOrArray )
    {
        return $objectOrArray->addresses;
    }
    

};


        $this->classPropertyAccessors = [
"Proxy\\__GC__\\"     =>  $autoGeneratedAnonymousClass_1,
"Client"     =>  $autoGeneratedAnonymousClass_1
        ];
    }

    /**
     * {@inheritdoc}
     */
    public function setValue(&$objectOrArray, $propertyPath, $value)
    {
        $class = get_class($objectOrArray);
        return $this->classPropertyAccessors[$class]->setValue($objectOrArray, $propertyPath, $value);
    }

    /**
     * {@inheritdoc}
     */
    public function getValue($objectOrArray, $propertyPath)
    {
        $class = get_class($objectOrArray);
        return $this->classPropertyAccessors[$class]->getValue($objectOrArray, $propertyPath);
    }

    /**
     * {@inheritdoc}
     */
    public function isWritable($objectOrArray, $propertyPath)
    {
        $class = get_class($objectOrArray);
        return $this->classPropertyAccessors[$class]->isWritable($objectOrArray, $propertyPath);
    }

    /**
     * {@inheritdoc}
     */
    public function isReadable($objectOrArray, $propertyPath)
    {
        $class = get_class($objectOrArray);
        return $this->classPropertyAccessors[$class]->isReadable($objectOrArray, $propertyPath);
    }

    /**
     * @param $object
     * @return bool
     */
    public function hasAccessTo($object)
    {
        $class = get_class($object);
        return isset($this->classPropertyAccessors[$class]);
    }

    /**
     * {@inheritdoc}
     */
    public function hasAccessToOperation($object, $property, $operation)
    {
        if (is_object($object)) {
            $class = get_class($object);
            if (isset($this->classPropertyAccessors[$class])) {
                return $this->classPropertyAccessors[$class]->hasAccessToOperation(
                    $property,
                    $operation
                );
            }
        }

        return false;
    }
}
````